
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module c16(

	//////////// LED //////////
	LEDG,
	LEDR,

	//////////// KEY //////////
	CPU_RESET_n,
	KEY,

	//////////// SW //////////
	SW,

	//////////// SEG7 //////////
	HEX0,
	HEX1,
	HEX2,
	HEX3 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// LED //////////
output		     [7:0]		LEDG;
output		     [9:0]		LEDR;

//////////// KEY //////////
input 		          		CPU_RESET_n;
input 		     [3:0]		KEY;

//////////// SW //////////
input 		     [9:0]		SW;

//////////// SEG7 //////////
output		     [6:0]		HEX0;
output		     [6:0]		HEX1;
output		     [6:0]		HEX2;
output		     [6:0]		HEX3;


/////////////////////////
// The processor state //
/////////////////////////
	 
    reg [15:0]regs[7:0];     // register
    reg [15:0]pc;             // the pc
	 
	initial begin
		pc = 0;
		regs[0] = 0;
		regs[1] = 0;
		regs[2] = 0;
		regs[3] = 0;
		regs[4] = 0;
		regs[5] = 0;
		regs[6] = 0;
		regs[7] = 0;
	end
	 
///////////
// fetch //
///////////
	 
    reg [15:0]inst;           // the instruction
	 
    // hardwired program, need to start some where
    always @(*) begin
        case(pc)                          // Instruction                      Binary              Result
            16'h0000 : inst = 16'h0002;   // add   r0 := r0 + 2               b00000000 00000010  r0=2
            16'h0001 : inst = 16'h07E2;   // add   Z := Z + 2                 b00000111 11100010  z=0, z is constant  
            16'h0002 : inst = 16'h0807;   // add   r0 := r0 + Z               b00001000 00000111  no change in state  
            16'h0003 : inst = 16'h0124;   // add   r1 := r1 + 4               b00000001 00100100  r1=4
            16'h0004 : inst = 16'h0A01;   // add   r2 := r0 + r1              b00001010 00000001  r2=6
            16'h0005 : inst = 16'h0A41;   // add   r2 := r2 + r1              b00001010 01000001  r2=Ah
            
            16'h0006 : inst = 16'h234B;   // slt   r3 := r2 < 4'Bh            b00100011 01001011  r3=1
            16'h0007 : inst = 16'h2B22;   // slt   r3 := r1 < r2              b00101011 00100010  r3=1
            16'h0008 : inst = 16'h2B41;   // slt   r3 := r2 < r1              b00101011 01000001  r3=0
            16'h0009 : inst = 16'h2B61;   // slt   r3 := r3 < r1              b00101011 01100001  r3=1
 
            16'h000A : inst = 16'hC35F;   // lea   r3 := r2 + 1Fh             b11000011 01011111  r3=29h
            16'h000B : inst = 16'hCB20;   // lea   r3 := pc + 20h             b11001011 00100000  r3=2Bh
            
            16'h000C : inst = 16'hD561;   // call  r5 := pc; pc := r3 + 1     b11010101 01100001  r5=Ch, pc=002Ch
            16'h002C : inst = 16'hDD03;   // call  r5 := pc; pc := pc + 3     b11011101 00000011  r5=2Ch, pc=002Fh
            
            16'h002F : inst = 16'h04E0;   // add   r4 := Z + 0 => li r4,0     b00000100 11100000  r4=0
            16'h0030 : inst = 16'hF467;   // brz   pc := r3 + 7h if r4 == 0   b11110100 01100111  pc=0032h
            16'h0032 : inst = 16'hF067;   // brz   pc := r3 + 7h if r0 == 0   b11110000 01100111  no change in state
            16'h0033 : inst = 16'hFC04;   // brz   pc := pc + 4 if r4 == 0    b11111100 00000100  pc=0037h
            16'h0037 : inst = 16'hF804;   // brz   pc := pc + 4 if r0 == 0    b11111000 00000100  no change in state
            16'h0038 : inst = 16'h8664;   // shl   r6 := r3 << 4              b10000110 01100100  r6=2B0h
            16'h0039 : inst = 16'h85A1;   // shl   r5 := r5 << 1              b10000101 10100001  r5=58h
            16'h003A : inst = 16'h85A3;   // shl   r5 := r5 << 3              b10000101 10100011  r5=2C0h
            16'h003B : inst = 16'hFF00;   // brz   pc := pc + 0 => halt       b11111111 00000000  halt
            default: inst = 16'bxxxxxxxxxxxxxxxx;
            // Final State r0 = 2, r1 = 4, r2 = Ah, r3 = 2Bh, r4 = 0, r5 = 2C0h, r6 = 2B0h, r7 = 0 (Z) 
        endcase
    end
	 
	///////////////////
	// decode & regs //
	///////////////////

    // Fields in the instruction
    wire [4:0] opcode = inst[15:11];
    wire [2:0] rd = inst[10:8];
    wire [2:0] ra = inst[7:5];
    wire [2:0] rb = inst[2:0];
    // Immediate values, sign extended using our custom module
    wire [15:0] imm5;
    wire [15:0] imm8;
    sign_extend_16 #(5) (inst[4:0], imm5);
    sign_extend_16 #(8) (inst[7:0], imm8);
    // Values loaded from registers
    wire [15:0] va = regs[ra];
    wire [15:0] vb = regs[rb];
    wire [15:0] vd = regs[rd];
 
/////////////
// execute //
/////////////
 
reg [15:0] nextpc;        // the next pc
reg rfen;                 // this instructions modifies a register
reg [15:0]rfdata;         // the register value
 
always @(*) begin
    rfen = 0;
    rfdata = 0;
    nextpc = pc + 1;
    case (opcode)
        // Add, f = 0
        5'b00000: begin
            rfen = 1;
            rfdata = imm5 + va;
        end
        
        // Add, f = 1
        5'b00001: begin
            rfen = 1;
            rfdata = va + vb;
    	end
             
        // Slt, f = 0
        5'b00100: begin
            rfen = 1;
            rfdata = (va < imm5);
        end
         
        // Slt, f = 1
        5'b00101: begin
            rfen = 1;
            rfdata = (va < vb);
        end
            
        // Lea, f = 0
        5'b11000: begin
            rfen = 1;
            rfdata = va + imm5;
        end
            
        // Lea, f = 1
        5'b11001: begin
            rfen = 1;
            rfdata = pc + imm8;
        end
            
         // Call, f = 0
        5'b11010: begin
            rfen = 1;
            rfdata = pc;
            nextpc = va + imm5;
        end
            
        // Call, f = 1
        5'b11011: begin
            rfen = 1;
            rfdata = pc;
            nextpc = pc + imm8;
        end
            
        // brz, f = 0
        5'b11110: begin
            if (vd == 0)
                nextpc = va + imm5;
        end
            
        //brazos, f = 1
        5'b11111: begin
            if (vd == 0)
                nextpc = pc + imm8;
        end
            
        //shell, f = 0
        5'b10000: begin
            rfen = 1;
            rfdata = va << imm5[3:0];
        end
				
    	//shell, f = 1
        5'b10001: begin
            rfen = 1;
            rfdata = va << imm5[3:0];
        end
				
    endcase
end
	 
wire clk = KEY[0];        // single step using key0
	 
///////////////////
// debug support //
///////////////////
reg [15:0]debug;
assign LEDG = inst[15:8];
assign LEDR = pc[9:0];
display(debug[15:12], HEX3);
display(debug[11:8], HEX2);
display(debug[7:4], HEX1);
display(debug[3:0], HEX0);

// what do we display
always @(*) begin
    if (SW[3]) debug = pc;
    else debug = regs[SW[2:0]];
end

/////////////////////////
// The sequential part //
/////////////////////////
	 
always @(posedge clk) begin
    pc <= nextpc;
    // If the target is R7, don't write out the value
    if (rfen && rd != 7) regs[rd] <= rfdata;
end

endmodule

module display(NUM, HEX);
	input[3:0] NUM;
	
	output[6:0] HEX;
	reg[6:0] HEX;

	always @(*)
	case (NUM)
		4'h0 : HEX = 7'b1000000;
		4'h1 : HEX = 7'b1111001;
		4'h2 : HEX = 7'b0100100;
		4'h3 : HEX = 7'b0110000;
		4'h4 : HEX = 7'b0011001;
		4'h5 : HEX = 7'b0010010;
		4'h6 : HEX = 7'b0000010;
		4'h7 : HEX = 7'b1111000;
		4'h8 : HEX = 7'b0000000;
		4'h9 : HEX = 7'b0010000;
		4'hA : HEX = 7'b0001000;
		4'hB : HEX = 7'b0000011;
		4'hC : HEX = 7'b0100111;
		4'hD : HEX = 7'b0100001;
		4'hE : HEX = 7'b0000110;
		4'hF : HEX = 7'b0001110;
	endcase
endmodule

// Sign extension module
module sign_extend_16(IN, OUT);
    // The width of the input value in bits
    parameter INPUT_WIDTH;
    input [INPUT_WIDTH - 1:0]IN;
    output [15:0]OUT;
    
    reg [15:0] result;
    reg [15:0] all1 = 16'hffff;
    reg [15:0] all0 = 16'h0;
    
    always @(*)
        if (IN[INPUT_WIDTH - 1]) begin
            result[INPUT_WIDTH - 1:0] = IN;
            result[15:INPUT_WIDTH] = all1[15:INPUT_WIDTH];
        end else begin
            result[INPUT_WIDTH - 1:0] = IN;
            result[15:INPUT_WIDTH] = all0[15:INPUT_WIDTH];
        end
    
    assign OUT = result;
    
endmodule
